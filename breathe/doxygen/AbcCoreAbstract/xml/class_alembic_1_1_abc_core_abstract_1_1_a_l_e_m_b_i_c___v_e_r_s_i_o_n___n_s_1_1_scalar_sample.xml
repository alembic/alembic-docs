<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.6.1">
  <compounddef id="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample" kind="class" prot="public">
    <compoundname>Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample</compoundname>
    <includes refid="_scalar_sample_8h" local="no">ScalarSample.h</includes>
    <innerclass refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1_1_data" prot="public">Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample::Data</innerclass>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1a97525375912a4b065f0c7916632add05" prot="private" static="no" mutable="no">
        <type><ref refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_data_type" kindref="compound">DataType</ref></type>
        <definition>DataType Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample::m_dataType</definition>
        <argsstring></argsstring>
        <name>m_dataType</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" line="184" bodyfile="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" bodystart="184" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1a899535689e515e4b03e6277c577afc64" prot="private" static="no" mutable="no">
        <type>Alembic::Util::unique_ptr&lt; <ref refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1_1_data" kindref="compound">Data</ref> &gt;</type>
        <definition>Alembic::Util::unique_ptr&lt;Data&gt; Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample::m_data</definition>
        <argsstring></argsstring>
        <name>m_data</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" line="185" bodyfile="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" bodystart="185" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1a8bbd76caa1bcfa0d3b4e148492bbb627" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample::ScalarSample</definition>
        <argsstring>(const DataType &amp;iDataType)</argsstring>
        <name>ScalarSample</name>
        <param>
          <type>const <ref refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_data_type" kindref="compound">DataType</ref> &amp;</type>
          <declname>iDataType</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Construct from given data type and data. <ref refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1_1_data" kindref="compound">Data</ref> will be copied. If given data is NULL, internal data will be set to default value. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" line="86"/>
      </memberdef>
      <memberdef kind="function" id="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1a1187e485215347cc226192b2f62b6bc5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample::copyFrom</definition>
        <argsstring>(const void *iData)</argsstring>
        <name>copyFrom</name>
        <param>
          <type>const void *</type>
          <declname>iData</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assignment to just data. Will assume data is of the same type as described internally by our data type. is invalid to set to NULL here. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" line="93" bodyfile="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" bodystart="92" bodyend="95"/>
      </memberdef>
      <memberdef kind="function" id="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1ad4b114f33af5ce136553bb91b92cd130" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_data_type" kindref="compound">DataType</ref> &amp;</type>
        <definition>const DataType&amp; Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample::getDataType</definition>
        <argsstring>() const </argsstring>
        <name>getDataType</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the datatype. ... </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" line="103" bodyfile="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" bodystart="103" bodyend="103"/>
      </memberdef>
      <memberdef kind="function" id="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1acfbff1940cfe6d0c6ff91018e072cbcb" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const void *</type>
        <definition>const void* Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample::getData</definition>
        <argsstring>() const </argsstring>
        <name>getData</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the memory address corresponding to the data ... </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" line="107" bodyfile="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" bodystart="107" bodyend="107"/>
      </memberdef>
      <memberdef kind="function" id="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1ab41b4fa7056e072826f01ceccf778c7c" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample::operator==</definition>
        <argsstring>(const void *iRhs) const </argsstring>
        <name>operator==</name>
        <param>
          <type>const void *</type>
          <declname>iRhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assuming the passed memory address points to data of the same type as us, are they equal? An element-by-element comparison is done. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" line="117" bodyfile="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" bodystart="116" bodyend="119"/>
      </memberdef>
      <memberdef kind="function" id="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1ad80f89c22f8b5cf38901899552af35a4" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample::operator==</definition>
        <argsstring>(const ScalarSample &amp;iRhs) const </argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample" kindref="compound">ScalarSample</ref> &amp;</type>
          <declname>iRhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Are the data types exactly equal? This will do an element-by-element comparison. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" line="124" bodyfile="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" bodystart="123" bodyend="127"/>
      </memberdef>
      <memberdef kind="function" id="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1a97632f9bcc5b09623036b26055fc005d" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample::equalWithRelAbsError</definition>
        <argsstring>(const void *iRhs, double iRelAbsError) const </argsstring>
        <name>equalWithRelAbsError</name>
        <param>
          <type>const void *</type>
          <declname>iRhs</declname>
        </param>
        <param>
          <type>double</type>
          <declname>iRelAbsError</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Are the data types equal with some precision. This only applies to floating point types, but will just ignore the relAbsError for the non-floating-point types. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" line="134" bodyfile="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" bodystart="132" bodyend="136"/>
      </memberdef>
      <memberdef kind="function" id="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1a6c9f951c71440922c659298a248a1155" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample::equalWithRelAbsError</definition>
        <argsstring>(const ScalarSample &amp;iRhs, double iRelAbsError) const </argsstring>
        <name>equalWithRelAbsError</name>
        <param>
          <type>const <ref refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample" kindref="compound">ScalarSample</ref> &amp;</type>
          <declname>iRhs</declname>
        </param>
        <param>
          <type>double</type>
          <declname>iRelAbsError</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Same as precision-bound equality operator above. ... </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" line="142" bodyfile="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" bodystart="140" bodyend="145"/>
      </memberdef>
      <memberdef kind="function" id="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1ae7ffa09ba4aeea8932cf045883fc369f" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample::operator&lt;</definition>
        <argsstring>(const void *iRhs) const </argsstring>
        <name>operator&lt;</name>
        <param>
          <type>const void *</type>
          <declname>iRhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sorting operator. Compares element by element, with first elements having precedence over later ones. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" line="150" bodyfile="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" bodystart="149" bodyend="152"/>
      </memberdef>
      <memberdef kind="function" id="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1a3a5881ea1783d493641f377370b48853" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample::operator&lt;</definition>
        <argsstring>(const ScalarSample &amp;iRhs) const </argsstring>
        <name>operator&lt;</name>
        <param>
          <type>const <ref refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample" kindref="compound">ScalarSample</ref> &amp;</type>
          <declname>iRhs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sorting operator. Compares element by element, with first elements having precedence over later ones. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" line="157" bodyfile="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" bodystart="156" bodyend="170"/>
      </memberdef>
      <memberdef kind="function" id="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1a9e7f08fac712e3393a611864fdae2328" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample::setToDefault</definition>
        <argsstring>()</argsstring>
        <name>setToDefault</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sets to to default values for whichever POD types are contained. ... </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" line="179" bodyfile="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" bodystart="178" bodyend="181"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><ref refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample" kindref="compound">ScalarSample</ref> is purely a helper class for implementations. It is not a required object of exchange within Alembic, and you wouldn&apos;t want this to be the carrier of data with scalars because you&apos;d be carrying around the extra 2 bytes of &quot;DataType&quot; data every time you passed data, which is wasteful and unnecessary.</para><para>However, since the Scalar Readers and Writers will always be obligated to compare samples to previously written samples and copy sample values, this class will be helpful in that regard.</para><para>Plus - and this is just a hunch - I suspect that as Alembic evolves, there will be a need for this extra bit of encapsulation at the abstract level, which is why I&apos;m putting it here. </para>    </detaileddescription>
    <collaborationgraph>
      <node id="74">
        <label>Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample</label>
        <link refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample"/>
        <childnode refid="75" relation="usage">
          <edgelabel>m_dataType</edgelabel>
        </childnode>
      </node>
      <node id="75">
        <label>Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::DataType</label>
        <link refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_data_type"/>
      </node>
    </collaborationgraph>
    <location file="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" line="64" bodyfile="/var/tmp/doNotRemove/local/alembic-1.6.0/include/Alembic/AbcCoreAbstract/ScalarSample.h" bodystart="62" bodyend="186"/>
    <listofallmembers>
      <member refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1a1187e485215347cc226192b2f62b6bc5" prot="public" virt="non-virtual"><scope>Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample</scope><name>copyFrom</name></member>
      <member refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1a97632f9bcc5b09623036b26055fc005d" prot="public" virt="non-virtual"><scope>Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample</scope><name>equalWithRelAbsError</name></member>
      <member refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1a6c9f951c71440922c659298a248a1155" prot="public" virt="non-virtual"><scope>Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample</scope><name>equalWithRelAbsError</name></member>
      <member refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1acfbff1940cfe6d0c6ff91018e072cbcb" prot="public" virt="non-virtual"><scope>Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample</scope><name>getData</name></member>
      <member refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1ad4b114f33af5ce136553bb91b92cd130" prot="public" virt="non-virtual"><scope>Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample</scope><name>getDataType</name></member>
      <member refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1a899535689e515e4b03e6277c577afc64" prot="private" virt="non-virtual"><scope>Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample</scope><name>m_data</name></member>
      <member refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1a97525375912a4b065f0c7916632add05" prot="private" virt="non-virtual"><scope>Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample</scope><name>m_dataType</name></member>
      <member refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1ae7ffa09ba4aeea8932cf045883fc369f" prot="public" virt="non-virtual"><scope>Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample</scope><name>operator&lt;</name></member>
      <member refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1a3a5881ea1783d493641f377370b48853" prot="public" virt="non-virtual"><scope>Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample</scope><name>operator&lt;</name></member>
      <member refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1ab41b4fa7056e072826f01ceccf778c7c" prot="public" virt="non-virtual"><scope>Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample</scope><name>operator==</name></member>
      <member refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1ad80f89c22f8b5cf38901899552af35a4" prot="public" virt="non-virtual"><scope>Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample</scope><name>operator==</name></member>
      <member refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1a8bbd76caa1bcfa0d3b4e148492bbb627" prot="public" virt="non-virtual"><scope>Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample</scope><name>ScalarSample</name></member>
      <member refid="class_alembic_1_1_abc_core_abstract_1_1_a_l_e_m_b_i_c___v_e_r_s_i_o_n___n_s_1_1_scalar_sample_1a9e7f08fac712e3393a611864fdae2328" prot="public" virt="non-virtual"><scope>Alembic::AbcCoreAbstract::ALEMBIC_VERSION_NS::ScalarSample</scope><name>setToDefault</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
